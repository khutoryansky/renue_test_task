
# Тестовое задание Renue
Для реализации такого автоматического решения был выбран инструмет управления конфигурацией **Ansible**.
Ansible был выбран по ряду причин. Во-первых, он является **_agentless_** инструментом в отличие от аналогов, что не требует установки дополнительных агентов на целевых серверах, следовательно - упрощается управление. Во-вторых, плейбуки Ansible гарантируют, что задачи будут выполнены корректно независимо от количества запусков. Также, удобное разбиение по ролям - облегчает процесс структурирования конфигурации. И плюсом является популярность Ansible, огромное количество модулей для работы с пакетами, файлами, пользователями, сервисами и т.д.

## Задание 
>Есть 2 сервера: A и Б (hostA.renue и hostB.renue соответственно). Ubuntu Server 20.04 LTS без предустановленных пакетов и программ. Необходимо предложить автоматизированное решение, которое позволит:
```
1. Отключить авторизацию SSH по паролю. На обоих серверах.
2. Добавить пользователя DevOps, настроить авторизацию по ключам и предоставить 
sudo без пароля. На обоих серверах. 
3. Настроить fail2ban на сервере А с блокировкой на 1 час, если в течение 1 минуты 
было 3 неудачных попыток входа.
4. На сервер A установить PostgreSQL, создать БД app и custom:
	a) добавить пользователя app с паролем app, у которого будет полный доступ к БД app;
	b) добавить пользователя custom с паролем custom, у которого будет полный доступ к БД custom;
	c) добавить пользователя service с паролем service, у которого будет доступ на чтение к обеим базам.
5. На сервер Б установить nginx и настроить его так, чтобы при обращении на сервере к localhost (или его доменному имени) открывался сайт https://renue.ru.
6. Настроить доступ к PostgreSQL на сервере А только с сервера Б, закрыть доступ к nginx на сервере Б с сервера А.
7. Настроить бэкапирование PostgreSQL с сервера А на сервер Б.
```
## Структура проекта

ansible/
├── ansible.cfg
├── hosts.ini
├── main-playbook.yml
├── roles/
│   ├── backups/
│   │   ├── tasks/main.yml
│   │   └── templates/
│   │       └── pg_backup.sh.j2
│   ├── backups_b/
│   │   └── tasks/main.yml
│   ├── postgresql/
│   │   ├── tasks/main.yml
│   │   ├── templates/pg_hba.conf.j2
│   │   ├── handlers/main.yml
│   │   └── files/db_setup.sql
│   ├── nginx/
│   │   ├── tasks/main.yml
│   │   ├── handlers/main.yml
│   │   └── templates/
│   │       └── renue.conf.j2
│   └── fail2ban/
│       ├── handlers/main.yml
│       └── tasks/main.yml
└── first/
    ├── files/sudoers_devops
    ├── group_vars/ all_groups
    ├── master-script.ssh
    ├── hosts.ini 
    └── playbook.yml
        


## Детальное описание шагов и решений
>Было принято решение сначала настроить подключение по ssh ключам, а потом произвести отключение парольной аутентификации. Это позволит избежать проблемы, когда после отключения  аутентификации  по паролю, но до настройки shh соединения, могут произойти технические неполадки, (например, пропадет интернет соединение) и мы потеряем доступ к хосту.
### 1. Создание пользователя DevOps

- **Задача:** Добавить пользователя `DevOps` на обоих серверах, настроить ключевую аутентификацию и предоставить права sudo без пароля.
- **Реализация:**  
  - Модуль `user` создаёт пользователя.
  - Модуль `authorized_key` добавляет публичный ключ в `~DevOps/.ssh/authorized_keys`.
  - Модуль `copy` копирует файл sudoers (с содержимым `DevOps ALL=(ALL) NOPASSWD:ALL`) в `/etc/sudoers.d/DevOps`.
  
### 2. Отключение SSH парольной аутентификации

- **Задача:** Отключить возможность подключения по паролю для повышения безопасности.
- **Реализация:**  
  - Модуль Ansible `lineinfile` изменяет файл `/etc/ssh/sshd_config`, заменяя или добавляя строку `PasswordAuthentication no`.
  - После этого вызывается handler, который перезапускает SSH.


### 3. Настройка fail2ban

- **Задача:** Настроить fail2ban на сервере A, чтобы блокировать IP на 1 час при 3 неудачных попытках входа в течение 1 минуты.
- **Реализация:**  
  - Установка пакета fail2ban через модуль apt.
  - Развёртывание конфигурационных файлов (jail.d/ssh.conf) с заданными параметрами: `findtime=60`, `maxretry=3`, `bantime=3600`.
  - Перезапуск fail2ban после внесения изменений.
  > Так как ранее была отключена авторизация по паролю, настройка fail2ban не совсем очевидна

### 4. Установка и настройка PostgreSQL

- **Задача:** Установить PostgreSQL, создать базы `app` и `custom`, а также пользователей:
  - `app` – полный доступ к базе `app`
  - `custom` – полный доступ к базе `custom`
  - `service` – доступ на чтение (SELECT) к обеим базам.
- **Реализация:**  
  - Установка необходимых пакетов (postgresql, postgresql-client-common, python3-psycopg2) производится с помощью модуля apt.
  - Копирование SQL-скрипта на целевой сервер с помощью модуля `copy`. После чего модулт `command` выполняет SQL - скрипт настройки, с помощью `psql` от пользователя `postgres`
  - Разворачивается шаблон `pg_hba_conf.j2`, в котором ограничиваются подключения к PostgreSQL (разрешая доступ только с определённых IP-адресов (сервера Б)).
  - Обновляется параметра `listen_addresses` на `*` в файле `/etc/postgresql/12/main/postgresql.conf`, что позволяет PostgreSQL принимать подключения на всех интерфейсах.
  - Перезапускается сервис `postgresql`
  
### 5. Установка и настройка nginx

- **Задача:** На сервере Б установить nginx и настроить его так, чтобы при обращении к серверу (через `http://localhost` или доменное имя) открывался сайт [https://renue.ru](https://renue.ru).
- **Реализация:**  
  - Установка `nginx` через модуль `apt`.
  - Развёртывание конфигурационного шаблона `renue.conf.j2` в `/etc/nginx/sites-available/` и создание символической ссылки в `/etc/nginx/sites-enabled/`.
  - Конфигурация настроена как обратное проксирование (с использованием `proxy_pass` и соответствующих заголовков).

### 6. Ограничение доступа между серверами

- **Задача:** Ограничить доступ к PostgreSQL на сервере A так, чтобы подключаться могли только с сервера Б, и запретить доступ к nginx на сервере Б с сервера A.
- **Реализация:**  
  - Настройка `pg_hba.conf` в PostgreSQL для ограничения доступа по IP.
  - Немного не понятна формулировка _запретить доступ к nginx_, поэтому было принято решение использовать iptables для блокировки доступа к портам nginx `80 - http` и `443 -https` с IP сервера A.
  > Принято решение это сделать через iptables, а не через ufw, так как iptables по умолчанию не блокирует порты, например порт ssh 22, что могло бы разорвать ssh соединение и привести к последствиям.

### 7. Настройка резервного копирования PostgreSQL

- **Задача:** Настроить автоматизированное резервное копирование баз PostgreSQL с сервера A на сервер Б.
- **Реализация:**  
  - **Обмен SSH-ключами:**  
    — На сервере A генерируется ключ (`/home/DevOps/.ssh/backup_id_rsa`).
    — Публичный ключ добавляется в `authorized_keys` пользователя на сервере Б (для пользователя `DevOps`).
  - **Скрипт резервного копирования:**  
    — Шаблон `pg_backup.sh.j2` разворачивается на сервере A в `/usr/local/bin/pg_backup.sh`.
    — Скрипт создает дамп PostgreSQL (через `pg_dumpall`), сохраняет его в каталоге `/home/DevOps/var/backups/pg`, а затем передает через `scp` на сервер Б в каталог `/home/DevOps/var/backups/pg`.
    — В скрипте добавлена опция `-o StrictHostKeyChecking=no` и указание приватного ключа через флаг `-i`.
	 >  Понимаю что это небезопасная практика, но через ansible нет возможности подтвердить отпечаток (fingerprint) 
  - **Cron-задача:**  
    — Через модуль `cron` создается задание для регулярного выполнения скрипта (настроил ежедневно в 00:00).


## Запуск решения

Для успешного запуска решения необходимо:
1. Скачать решение на мастер-сервер
2. Перейти в каталог `ansible/first`
3. Добавить хосты серверов А и Б в ansible инвентарь `hosts`, также добавить пользователя (`ansible user=`) и пароль (`ansible_password=`) для первичного входа.
4. Дать разрешение на исполнения скрипту bash  `master_script.sh`, команда ```chmod a+x master_script.sh ```
5. Запустить  bash скрипт `./master_script.sh`
6. Перейти в каталог `ansible` и запустить ansible playbook ```ansible-playbook -i hosts main_playbook.yml ```

